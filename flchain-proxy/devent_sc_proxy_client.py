# CODE AUTOMATICALLY GENERATED BY sc-proxy-generator.py

from bech32 import bech32_encode, convertbits
import base64
import json

def hex_string_to_bech32_address(hex_str, hrp = 'erd'):
    hex_bytes = bytes.fromhex(hex_str.rstrip('\x00'))
    data = convertbits(hex_bytes, 8, 5)
    bech32_str = bech32_encode(hrp, data)
    return bech32_str
    
def base64_string_to_string(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    decoded_string = decoded_bytes.decode('utf-8')
    return decoded_string

def base64_string_to_bytes(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    return decoded_bytes

def hex_string_to_numeric(hex_string):
    if not hex_string:
        return 0
    numeric_value = int(hex_string.rstrip('\x00'), 16)
    return numeric_value

def hex_string_to_string(hex_string):
    if not hex_string:
        return 0
    decoded_bytes = bytes.fromhex(hex_string.rstrip('\x00'))
    decoded_string = decoded_bytes.decode('utf-8')
    return decoded_string

def base64_string_to_hex_string(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    hex_encoded = decoded_bytes.hex()
    return hex_encoded

def base64_string_to_numeric(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    numeric_value = hex_string_to_numeric(decoded_bytes)
    return numeric_value

def base64_string_to_bech32_address(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    bech32_address = hex_string_to_bech32_address(decoded_bytes)
    return bech32_address

def base64_string_to_graphTopology(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    vertices_count = decoded_bytes[:16] # 8 bytes x 2 = 16 chars for vertices count
    edges_count = decoded_bytes[16:32] # 8 bytes x 2 = 16 chars for edges count
    owner = decoded_bytes[32:96] # 32 bytes x 2 = 64 chars for owner address
    storage_addr = decoded_bytes[96:188] # 46 bytes x 2 = 92 chars for storage address
    timestamp = decoded_bytes[188:204] # 8 bytes x 2 = 16 chars for timestamp
    hash = decoded_bytes[204:] # 32 bytes x 2 = 64 chars for hash
    decoded_response = {
        'vertices_count': hex_string_to_numeric(vertices_count),
        'edges_count': hex_string_to_numeric(edges_count),
        'owner': hex_string_to_bech32_address(owner),
        'storage_addr': hex_string_to_string(storage_addr),
        'timestamp': hex_string_to_numeric(timestamp),
        'hash': hex_string_to_string(hash)
    }
    print(decoded_response)
    return decoded_response

from pathlib import Path
from multiversx_sdk_core import TokenComputer
from multiversx_sdk_core.transaction_factories import SmartContractTransactionsFactory
from multiversx_sdk_core import Transaction, TransactionComputer, Address
from multiversx_sdk_wallet.user_signer import UserSigner
from multiversx_sdk_core.transaction_factories import TransactionsFactoryConfig
from multiversx_sdk_core import ContractQueryBuilder
from multiversx_sdk_network_providers import ApiNetworkProvider
from multiversx_sdk_core import AccountNonceHolder

SC_ADDR = "erd1qqqqqqqqqqqqqpgqz82nup6jgsxhf0xzx6yyg4xm2tcqsd27ch8quuq97s"
CHAIN_ID = "D"
NETWORK_PROVIDER = "https://devnet-api.multiversx.com"
CHAIN_NAME = "devent"
CALLER_USER_ADDR = "erd1dwlm0pazs43q0sad8h3r7ueehlzjmhyyq9spryaxruhvfgwych8qgydtwz"
GAS_LIMIT = 60000000

transaction_factory_config = TransactionsFactoryConfig(CHAIN_ID)
transaction_computer = TransactionComputer()
sc_factory = SmartContractTransactionsFactory(transaction_factory_config, TokenComputer())
contract_address = Address.from_bech32(SC_ADDR)
network_provider = ApiNetworkProvider(NETWORK_PROVIDER)

def call_get_local_updates(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_local_updates",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'List<u32>'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def call_get_serialized_user_data(user_addr, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_serialized_user_data",
		call_arguments = [user_addr],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'List<bytes>'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def call_get_serialized_network_data(city_id, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_serialized_network_data",
		call_arguments = [city_id],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'GraphTopology'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_graphTopology
	decoded_response = decode_method(return_data)
	print(decoded_response)

call_get_serialized_network_data(1)

def call_get_graph_networks(city_id, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_graph_networks",
		call_arguments = [city_id],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'GraphTopology'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_graphTopology
	decoded_response = decode_method(return_data)
	print(decoded_response)

def call_get_users(user_addr, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_users",
		call_arguments = [user_addr],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'variadic<User>'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def call_get_files(author_addr, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_files",
		call_arguments = [author_addr],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'variadic<File>'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def call_get_users_count(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_users_count",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u64'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def call_get_files_count(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_files_count",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u64'
	if not output_type.startswith('List<'):
		return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

