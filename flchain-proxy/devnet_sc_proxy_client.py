# CODE AUTOMATICALLY GENERATED BY sc-proxy-generator.py

from bech32 import bech32_encode, convertbits
from datetime import datetime, timezone
import base64
import json

def hex_string_to_bech32_address(hex_str, hrp = 'erd'):
    hex_bytes = bytes.fromhex(hex_str.rstrip('\x00'))
    data = convertbits(hex_bytes, 8, 5)
    bech32_str = bech32_encode(hrp, data)
    return bech32_str
    
def base64_string_to_string(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    decoded_string = decoded_bytes.decode('utf-8')
    return decoded_string

def base64_string_to_bytes(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    return decoded_bytes

def hex_string_to_numeric(hex_string):
    if not hex_string:
        return 0
    numeric_value = int(hex_string.rstrip('\x00'), 16)
    return numeric_value

def hex_string_to_string(hex_string):
    if not hex_string:
        return 0
    decoded_bytes = bytes.fromhex(hex_string.rstrip('\x00'))
    decoded_string = decoded_bytes.decode('utf-8')
    return decoded_string

def base64_string_to_hex_string(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    hex_encoded = decoded_bytes.hex()
    return hex_encoded

def base64_string_to_numeric(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    numeric_value = hex_string_to_numeric(decoded_bytes)
    return numeric_value

def base64_string_to_bech32_address(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    bech32_address = hex_string_to_bech32_address(decoded_bytes)
    return bech32_address

def base64_string_to_array_of_bech32_addresses(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    bech32_addresses = []
    for i in range(0, len(decoded_bytes), 64):
        bech32_addresses.append(hex_string_to_bech32_address(decoded_bytes[i:i + 64]))
    return bech32_addresses

def base64_string_to_graphTopology(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    vertices_count = decoded_bytes[:16] # 8 bytes x 2 = 16 chars for vertices count
    edges_count = decoded_bytes[16:32] # 8 bytes x 2 = 16 chars for edges count
    owner = decoded_bytes[32:96] # 32 bytes x 2 = 64 chars for owner address
    storage_addr = decoded_bytes[96:188] # 46 bytes x 2 = 92 chars for storage address
    timestamp = decoded_bytes[188:204] # 8 bytes x 2 = 16 chars for timestamp
    hash = decoded_bytes[204:] # 32 bytes x 2 = 64 chars for hash
    decoded_response = {
        'vertices_count': hex_string_to_numeric(vertices_count),
        'edges_count': hex_string_to_numeric(edges_count),
        'owner': hex_string_to_bech32_address(owner),
        'storage_addr': hex_string_to_string(storage_addr),
        'timestamp': hex_string_to_numeric(timestamp),
        'hash': hex_string_to_string(hash)
    }
    print(decoded_response)
    return decoded_response

def hex_string_to_file(hex_string):
    if not hex_string:
        return 0
    file_location = hex_string[:92] # 46 bytes x 2 = 92 chars for file location
    file_type = hex_string[92:94] # 2 bytes x 1 = 2 chars for file type
    round = hex_string[94:102] # 2 bytes x 4 = 8 chars for round
    decoded_response = {
        'file_location': hex_string_to_string(file_location),
        'file_type': hex_string_to_numeric(file_type),
        'round': hex_string_to_numeric(round)
    }
    return decoded_response

def hex_string_to_training_data(hex_string):
    if not hex_string:
        return 0
    cluster_adj_matrix_addr = hex_string[:92] # 46 bytes x 2 = 92 chars for cluster adjacency matrix address
    dataset_addr = hex_string[92:184] # 46 bytes x 2 = 92 chars for dataset address
    aggr_cluser_model_addr = hex_string[184:276] # 46 bytes x 2 = 92 chars for aggregated cluster model address
    footprint_model_addr = hex_string[276:368] # 46 bytes x 2 = 92 chars for footprint model address
    local_node_index = hex_string[368:372] # 2 bytes x 2 = 4 chars for local node index
    decoded_response = {
        'cluster_adj_matrix_addr': hex_string_to_string(cluster_adj_matrix_addr),
        'dataset_addr': hex_string_to_string(dataset_addr),
        'aggr_cluser_model_addr': hex_string_to_string(aggr_cluser_model_addr),
        'footprind_model_addr': hex_string_to_string(footprint_model_addr),
        'local_node_index': hex_string_to_numeric(local_node_index)
    }
    return decoded_response

def base64_string_to_file_array(encoded_string):
    if not encoded_string:
        return []

    decoded_bytes = base64_string_to_hex_string(encoded_string)
    file_struct_size = 102
    segments = []
    for i in range(0, len(decoded_bytes), file_struct_size):
        segments.append(decoded_bytes[i:i + file_struct_size])
    
    decoded_response = []
    for i in range(0, len(segments)):
        segment = segments[i]    
        decoded_response.append(hex_string_to_file(segment))
        
    return decoded_response

def base64_string_to_file(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    decoded_response = hex_string_to_file(decoded_bytes)
    return decoded_response

def base64_string_to_ipfs_addresses(encoded_string):
    if not encoded_string:
        return []
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    ipfs_addresses = []
    ipfs_cdv1_addr_size = 46 * 2
    for i in range(0, len(decoded_bytes), ipfs_cdv1_addr_size):
        ipfs_addresses.append(hex_string_to_string(decoded_bytes[i:i + ipfs_cdv1_addr_size]))
    return ipfs_addresses

def base64_string_to_ipfs_address(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    decoded_response = hex_string_to_string(decoded_bytes)
    return decoded_response

def base64_string_to_training_data(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    decoded_response = hex_string_to_training_data(decoded_bytes)
    return decoded_response

def base64_string_to_list_u16(encoded_string):
    if not encoded_string:
        return []
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    u16_numbers = []
    u16_part_size = 4
    for i in range(0, len(decoded_bytes), u16_part_size):
        decoded_response = hex_string_to_numeric(decoded_bytes[i:i + u16_part_size])    
        u16_numbers.append(decoded_response)
    return u16_numbers

def base64_string_to_list_cluster_node(encoded_string):
    if not encoded_string:
        return []
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    cluster_node_size = 8 # 4 bytes + 4 bytes
    cluster_nodes = []
    for i in range(0, len(decoded_bytes), cluster_node_size):
        cluster_nodes.append({
            'global_node_index': hex_string_to_numeric(decoded_bytes[i:i + 4]),
            'local_node_index': hex_string_to_numeric(decoded_bytes[i + 4:i + 8])
        })
    return cluster_nodes

def base64_string_to_node_cluser(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    decoded_response = {
        'global_node_index': hex_string_to_numeric(decoded_bytes[:4]),
        'cluster_index': hex_string_to_numeric(decoded_bytes[4:])
    }
    return decoded_response

def base64_string_to_list_evaluations(encoded_string):
    if not encoded_string:
        return []
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    evaluation_size = 66 # 64 bytes + 2 bytes
    evaluations = []
    for i in range(0, len(decoded_bytes), evaluation_size):
        evaluations.append({
            'evaluator': hex_string_to_bech32_address(decoded_bytes[i:i + 64]),
            'evaluation': hex_string_to_numeric(decoded_bytes[i + 64:i + 66])
        })
    return evaluations

import logging
from pathlib import Path
from multiversx_sdk import TokenComputer
from multiversx_sdk import SmartContractTransactionsFactory
from multiversx_sdk import Transaction, TransactionComputer, Address
from multiversx_sdk import UserSigner
from multiversx_sdk import TransactionsFactoryConfig
from multiversx_sdk import ContractQueryBuilder
from multiversx_sdk import ApiNetworkProvider
from multiversx_sdk import AccountNonceHolder

LOGGER_OUTPUT = "/home/robert/Desktop/Facultate/Licenta/Traffic-Prediction-FLChain/logs.log"
SC_ADDR = "erd1qqqqqqqqqqqqqpgqhq5rwx3effnxvllgpyettrpkwj7a5uyhch8qqmz30z"
CHAIN_ID = "D"
NETWORK_PROVIDER = "https://devnet-api.multiversx.com"
CHAIN_NAME = "devnet"
CALLER_USER_ADDR = "erd1rxufcd8sn9t2k5cavngu60qeeytkuxymajdarnyq5f8enh850wpq8at8xu"
WALLET_PATH = "/home/robert/Desktop/Facultate/Licenta/Traffic-Prediction-FLChain/wallets/master.pem"
GAS_LIMIT = 600000000

transaction_factory_config = TransactionsFactoryConfig(CHAIN_ID)
transaction_computer = TransactionComputer()
sc_factory = SmartContractTransactionsFactory(transaction_factory_config)
contract_address = Address.from_bech32(SC_ADDR)
network_provider = ApiNetworkProvider(NETWORK_PROVIDER)

# Dictionary to store the nonce for each user
# The chain gateway is slower in updating the nonce, so we need
# to keep track of it to avoid nonce desynchronization errors
nonce_cache = {} 

logging.basicConfig(
	level=logging.INFO,
	format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
	handlers=[logging.FileHandler(LOGGER_OUTPUT), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

def query_get_all_clusters_per_node(node_global_index, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_all_clusters_per_node",
			call_arguments = [node_global_index],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_all_clusters_per_node...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'List<u16>'
		return_data = return_data[0]
		decode_method = base64_string_to_list_u16
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_all_nodes_per_cluster(cluster_index, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_all_nodes_per_cluster",
			call_arguments = [cluster_index],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_all_nodes_per_cluster...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'List<ClusterNode>'
		return_data = return_data[0]
		decode_method = base64_string_to_list_cluster_node
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_all_round_files(round, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_all_round_files",
			call_arguments = [round],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_all_round_files...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'List<File>'
		return_data = return_data[0]
		decode_method = base64_string_to_file_array
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_training_data(global_node_index, cluster_index, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_training_data",
			call_arguments = [global_node_index, cluster_index],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_training_data...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'TrainingData'
		return_data = return_data[0]
		decode_method = base64_string_to_training_data
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_all_file_evaluations(file_location, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_all_file_evaluations",
			call_arguments = [file_location],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_all_file_evaluations...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'List<Evaluation>'
		return_data = return_data[0]
		decode_method = base64_string_to_list_evaluations
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_users_by_role(role, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_users_by_role",
			call_arguments = [role],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_users_by_role...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'List<Address>'
		return_data = return_data[0]
		decode_method = base64_string_to_array_of_bech32_addresses
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_candidate_models_for_aggregation(cluster_index, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_candidate_models_for_aggregation",
			call_arguments = [cluster_index],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_candidate_models_for_aggregation...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'List<array46<u8>>'
		return_data = return_data[0]
		decode_method = base64_string_to_ipfs_addresses
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_node_dataset(global_node_index, cluster_index, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_node_dataset",
			call_arguments = [global_node_index, cluster_index],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_node_dataset...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'array46<u8>'
		return_data = return_data[0]
		decode_method = base64_string_to_ipfs_address
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_cluster_adjacency_matrix(cluster_index, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_cluster_adjacency_matrix",
			call_arguments = [cluster_index],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_cluster_adjacency_matrix...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'array46<u8>'
		return_data = return_data[0]
		decode_method = base64_string_to_ipfs_address
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_cluster_aggregation_model(cluster_index, round, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_cluster_aggregation_model",
			call_arguments = [cluster_index, round],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_cluster_aggregation_model...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'array46<u8>'
		return_data = return_data[0]
		decode_method = base64_string_to_ipfs_address
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_candidate_model(global_node_index, cluster_index, round, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_candidate_model",
			call_arguments = [global_node_index, cluster_index, round],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_candidate_model...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'array46<u8>'
		return_data = return_data[0]
		decode_method = base64_string_to_ipfs_address
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_footprint_model(global_node_index, cluster_index, round, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_footprint_model",
			call_arguments = [global_node_index, cluster_index, round],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_footprint_model...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'array46<u8>'
		return_data = return_data[0]
		decode_method = base64_string_to_ipfs_address
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_user(user_addr, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_user",
			call_arguments = [Address.new_from_bech32(user_addr)],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_user...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'User'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_file(file_location, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_file",
			call_arguments = [file_location],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_file...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'File'
		return_data = return_data[0]
		decode_method = base64_string_to_file
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_stake(user_addr, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_stake",
			call_arguments = [Address.new_from_bech32(user_addr)],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_stake...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'BigUint'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_reputation(user_addr, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_reputation",
			call_arguments = [Address.new_from_bech32(user_addr)],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_reputation...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'u32'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_file_author(file_location, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_file_author",
			call_arguments = [file_location],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_file_author...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'Address'
		return_data = return_data[0]
		decode_method = base64_string_to_bech32_address
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_file_cluster_node(file_location, caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_file_cluster_node",
			call_arguments = [file_location],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_file_cluster_node...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'NodeCluster'
		return_data = return_data[0]
		decode_method = base64_string_to_node_cluser
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_files_count(caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_files_count",
			call_arguments = [],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_files_count...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'u32'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_users_count(caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_users_count",
			call_arguments = [],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_users_count...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'u32'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_nodes_count(caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_nodes_count",
			call_arguments = [],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_nodes_count...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'u16'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_clusters_count(caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_clusters_count",
			call_arguments = [],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_clusters_count...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'u16'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_round(caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_round",
			call_arguments = [],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_round...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'u32'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def query_get_stage(caller_user_addr = CALLER_USER_ADDR):
	try:
		builder = ContractQueryBuilder(
			contract = contract_address,
			function = "get_stage",
			call_arguments = [],
			caller = Address.from_bech32(caller_user_addr)
		)
		query = builder.build()
		logger.info(f'>>>Performing immutable query to get_stage...')
		response = network_provider.query_contract(query).to_dictionary()
		logger.info(response)
		return_code = response['returnCode']
		if return_code != 'ok':
			logger.error('Error in the response')
			return None
		return_data = response['returnData']
		output_type = 'Stage'
		return_data = return_data[0]
		decode_method = base64_string_to_numeric
		decoded_response = decode_method(return_data)
		logger.info(decoded_response)
		return decoded_response
	except Exception as e:
		logger.error(f'Error in the query: {e}')

def mutate_upload_dataset_file(file_location, global_node_index, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		global_node_index - u16
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="upload_dataset_file",
			gas_limit=gas_limit,
			arguments=[file_location, global_node_index, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to upload_dataset_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_upload_candidate_model_file(file_location, global_node_index, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		global_node_index - u16
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="upload_candidate_model_file",
			gas_limit=gas_limit,
			arguments=[file_location, global_node_index, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to upload_candidate_model_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_upload_footprint_model_file(file_location, global_node_index, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		global_node_index - u16
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="upload_footprint_model_file",
			gas_limit=gas_limit,
			arguments=[file_location, global_node_index, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to upload_footprint_model_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_upload_cluster_aggregation_file(file_location, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="upload_cluster_aggregation_file",
			gas_limit=gas_limit,
			arguments=[file_location, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to upload_cluster_aggregation_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_upload_adj_matrix_file(file_location, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="upload_adj_matrix_file",
			gas_limit=gas_limit,
			arguments=[file_location, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to upload_adj_matrix_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_dataset_file(file_location, global_node_index, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		global_node_index - u16
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_dataset_file",
			gas_limit=gas_limit,
			arguments=[file_location, global_node_index, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_dataset_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_cluster_aggregation_file(file_location, cluster_index, round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		cluster_index - u16
		round - u32
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_cluster_aggregation_file",
			gas_limit=gas_limit,
			arguments=[file_location, cluster_index, round]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_cluster_aggregation_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_footprint_model_file(file_location, global_node_index, cluster_index, round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		global_node_index - u16
		cluster_index - u16
		round - u32
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_footprint_model_file",
			gas_limit=gas_limit,
			arguments=[file_location, global_node_index, cluster_index, round]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_footprint_model_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_candidate_model_file(file_location, global_node_index, cluster_index, round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		global_node_index - u16
		cluster_index - u16
		round - u32
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_candidate_model_file",
			gas_limit=gas_limit,
			arguments=[file_location, global_node_index, cluster_index, round]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_candidate_model_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_adj_matrix_file(file_location, cluster_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		cluster_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_adj_matrix_file",
			gas_limit=gas_limit,
			arguments=[file_location, cluster_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_adj_matrix_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_all_round_files(round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		round - u32
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_all_round_files",
			gas_limit=gas_limit,
			arguments=[round]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_all_round_files for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_upload_cluster_description(cluster_index, global_node_index, local_node_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		cluster_index - u16
		global_node_index - u16
		local_node_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="upload_cluster_description",
			gas_limit=gas_limit,
			arguments=[cluster_index, global_node_index, local_node_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to upload_cluster_description for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_cluster_description(cluster_index, global_node_index, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		cluster_index - u16
		global_node_index - u16
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_cluster_description",
			gas_limit=gas_limit,
			arguments=[cluster_index, global_node_index]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_cluster_description for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_evaluate_file(file_location, status, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		file_location - array46<u8>
		status - EvaluationStatus
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="evaluate_file",
			gas_limit=gas_limit,
			arguments=[file_location, status]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to evaluate_file for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_signup_user(native_amount = 1, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="signup_user",
			gas_limit=gas_limit,
			native_transfer_amount=native_amount,
			arguments=[]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to signup_user for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_clear_user(wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="clear_user",
			gas_limit=gas_limit,
			arguments=[]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to clear_user for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_update_reputation(user_addr, reputation, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		user_addr - Address
		reputation - u32
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="update_reputation",
			gas_limit=gas_limit,
			arguments=[user_addr, reputation]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to update_reputation for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_next_round(wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="next_round",
			gas_limit=gas_limit,
			arguments=[]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to next_round for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_finalize_session(wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="finalize_session",
			gas_limit=gas_limit,
			arguments=[]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to finalize_session for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_set_round(round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		round - u32
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="set_round",
			gas_limit=gas_limit,
			arguments=[round]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to set_round for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_set_stage(stage, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		stage - Stage
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="set_stage",
			gas_limit=gas_limit,
			arguments=[stage]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to set_stage for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

def mutate_test_event(event_type, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR, gas_limit = GAS_LIMIT):
	"""Parameters description
		event_type - u8
	"""
	try:
		signer = UserSigner.from_pem_file(Path(wallet_path))
		user_addr = Address.from_bech32(caller_user_addr)
		nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
		call_transaction = sc_factory.create_transaction_for_execute(
			sender=user_addr,
			contract=contract_address,
			function="test_event",
			gas_limit=gas_limit,
			arguments=[event_type]
		)
		local_nonce = nonce_cache.get(caller_user_addr, -1)
		gateway_nonce = nonce_holder.get_nonce_then_increment()
		curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
		nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
		call_transaction.nonce = curr_nonce
		call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
		logger.info(f'>>>Performing mutable call to test_event for user address: {caller_user_addr}...')
		response = network_provider.send_transaction(call_transaction)
		logger.info(f'>>>Transaction hash: {response}')
	except Exception as e:
		logger.error(f'Error in the executing the transaction: {e}')

# mutate_clear_all_round_files(1)
# mutate_set_round(1)
# mutate_set_stage(3)
# mutate_test_event(5)
# mutate_set_stage(6)