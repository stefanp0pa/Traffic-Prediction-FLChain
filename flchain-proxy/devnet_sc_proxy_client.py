# CODE AUTOMATICALLY GENERATED BY sc-proxy-generator.py

from bech32 import bech32_encode, convertbits
import base64
import json

def hex_string_to_bech32_address(hex_str, hrp = 'erd'):
    hex_bytes = bytes.fromhex(hex_str.rstrip('\x00'))
    data = convertbits(hex_bytes, 8, 5)
    bech32_str = bech32_encode(hrp, data)
    return bech32_str
    
def base64_string_to_string(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    decoded_string = decoded_bytes.decode('utf-8')
    return decoded_string

def base64_string_to_bytes(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    return decoded_bytes

def hex_string_to_numeric(hex_string):
    if not hex_string:
        return 0
    numeric_value = int(hex_string.rstrip('\x00'), 16)
    return numeric_value

def hex_string_to_string(hex_string):
    if not hex_string:
        return 0
    decoded_bytes = bytes.fromhex(hex_string.rstrip('\x00'))
    decoded_string = decoded_bytes.decode('utf-8')
    return decoded_string

def base64_string_to_hex_string(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64.b64decode(encoded_string.rstrip('\x00'))
    hex_encoded = decoded_bytes.hex()
    return hex_encoded

def base64_string_to_numeric(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    numeric_value = hex_string_to_numeric(decoded_bytes)
    return numeric_value

def base64_string_to_bech32_address(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    bech32_address = hex_string_to_bech32_address(decoded_bytes)
    return bech32_address

def base64_string_to_array_of_bech32_addresses(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    bech32_addresses = []
    for i in range(0, len(decoded_bytes), 64):
        bech32_addresses.append(hex_string_to_bech32_address(decoded_bytes[i:i + 64]))
    return bech32_addresses

def base64_string_to_graphTopology(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    vertices_count = decoded_bytes[:16] # 8 bytes x 2 = 16 chars for vertices count
    edges_count = decoded_bytes[16:32] # 8 bytes x 2 = 16 chars for edges count
    owner = decoded_bytes[32:96] # 32 bytes x 2 = 64 chars for owner address
    storage_addr = decoded_bytes[96:188] # 46 bytes x 2 = 92 chars for storage address
    timestamp = decoded_bytes[188:204] # 8 bytes x 2 = 16 chars for timestamp
    hash = decoded_bytes[204:] # 32 bytes x 2 = 64 chars for hash
    decoded_response = {
        'vertices_count': hex_string_to_numeric(vertices_count),
        'edges_count': hex_string_to_numeric(edges_count),
        'owner': hex_string_to_bech32_address(owner),
        'storage_addr': hex_string_to_string(storage_addr),
        'timestamp': hex_string_to_numeric(timestamp),
        'hash': hex_string_to_string(hash)
    }
    print(decoded_response)
    return decoded_response

def hex_string_to_file(hex_string):
    if not hex_string:
        return 0
    file_location = hex_string[:92] # 46 bytes x 2 = 92 chars for file location
    file_type = hex_string[92:94] # 2 bytes x 1 = 2 chars for file type
    round = hex_string[94:102] # 2 bytes x 4 = 8 chars for round
    decoded_response = {
        'file_location': hex_string_to_string(file_location),
        'file_type': hex_string_to_numeric(file_type),
        'round': hex_string_to_numeric(round)
    }
    return decoded_response

def base64_string_to_file_array(encoded_string):
    if not encoded_string:
        return []

    decoded_bytes = base64_string_to_hex_string(encoded_string)
    file_struct_size = 102
    segments = []
    for i in range(0, len(decoded_bytes), file_struct_size):
        segments.append(decoded_bytes[i:i + file_struct_size])
    
    decoded_response = []
    for i in range(0, len(segments)):
        segment = segments[i]    
        decoded_response.append(hex_string_to_file(segment))
        
    print(decoded_response)
    return decoded_response

def base64_string_to_file(encoded_string):
    if not encoded_string:
        return 0
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    decoded_response = hex_string_to_file(decoded_bytes)
    return decoded_response

def base64_string_to_ipfs_addresses(encoded_string):
    decoded_bytes = base64_string_to_hex_string(encoded_string)
    ipfs_addresses = []
    ipfs_cdv1_addr_size = 46 * 2
    for i in range(0, len(decoded_bytes), ipfs_cdv1_addr_size):
        ipfs_addresses.append(hex_string_to_string(decoded_bytes[i:i + ipfs_cdv1_addr_size]))
    return ipfs_addresses

from pathlib import Path
from multiversx_sdk_core import TokenComputer
from multiversx_sdk_core.transaction_factories import SmartContractTransactionsFactory
from multiversx_sdk_core import Transaction, TransactionComputer, Address
from multiversx_sdk_wallet.user_signer import UserSigner
from multiversx_sdk_core.transaction_factories import TransactionsFactoryConfig
from multiversx_sdk_core import ContractQueryBuilder
from multiversx_sdk_network_providers import ApiNetworkProvider
from multiversx_sdk_core import AccountNonceHolder

SC_ADDR = "erd1qqqqqqqqqqqqqpgqumcqj0zzaqfxepa6e0azrfvplyk5wxndch8qjpdl6v"
CHAIN_ID = "D"
NETWORK_PROVIDER = "https://devnet-api.multiversx.com"
CHAIN_NAME = "devnet"
CALLER_USER_ADDR = "erd1dwlm0pazs43q0sad8h3r7ueehlzjmhyyq9spryaxruhvfgwych8qgydtwz"
WALLET_PATH = "/Users/stefan/Traffic-Prediction-FLChain/wallets/master.pem"
GAS_LIMIT = 60000000

transaction_factory_config = TransactionsFactoryConfig(CHAIN_ID)
transaction_computer = TransactionComputer()
sc_factory = SmartContractTransactionsFactory(transaction_factory_config, TokenComputer())
contract_address = Address.from_bech32(SC_ADDR)
network_provider = ApiNetworkProvider(NETWORK_PROVIDER)

# Dictionary to store the nonce for each user
# The chain gateway is slower in updating the nonce, so we need
# to keep track of it to avoid nonce desynchronization errors
nonce_cache = {} 

def query_get_file_evaluations(file_location, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_file_evaluations",
		call_arguments = [file_location],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_file_evaluations...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'List<Evaluation>'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_all_round_files(round, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_all_round_files",
		call_arguments = [round],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_all_round_files...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'List<File>'
	return_data = return_data[0]
	decode_method = base64_string_to_file_array
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_users_by_role(role, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_users_by_role",
		call_arguments = [role],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_users_by_role...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'List<Address>'
	return_data = return_data[0]
	decode_method = base64_string_to_array_of_bech32_addresses
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_graph_network(city_id, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_graph_network",
		call_arguments = [city_id],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_graph_network...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'GraphTopology'
	return_data = return_data[0]
	decode_method = base64_string_to_graphTopology
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_user(user_addr, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_user",
		call_arguments = [Address.new_from_bech32(user_addr)],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_user...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'User'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_user_addresses(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_user_addresses",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_user_addresses...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'variadic<Address>'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_file(file_location, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_file",
		call_arguments = [file_location],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_file...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'File'
	return_data = return_data[0]
	decode_method = base64_string_to_file
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_file_locations(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_file_locations",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_file_locations...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'variadic<array46<u8>>'
	return_data = return_data[0]
	decode_method = base64_string_to_ipfs_addresses
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_stake(user_addr, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_stake",
		call_arguments = [Address.new_from_bech32(user_addr)],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_stake...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'BigUint'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_reputation(user_addr, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_reputation",
		call_arguments = [Address.new_from_bech32(user_addr)],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_reputation...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u32'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_file_author(file_location, caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_file_author",
		call_arguments = [file_location],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_file_author...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'Address'
	return_data = return_data[0]
	decode_method = base64_string_to_bech32_address
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_files_count(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_files_count",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_files_count...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u32'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_users_count(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_users_count",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_users_count...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u32'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_graphs_count(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_graphs_count",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_graphs_count...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u32'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_round(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_round",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_round...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'u32'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def query_get_stage(caller_user_addr = CALLER_USER_ADDR):
	builder = ContractQueryBuilder(
		contract = contract_address,
		function = "get_stage",
		call_arguments = [],
		caller = Address.from_bech32(caller_user_addr)
	)
	query = builder.build()
	print(f'>>>Performing immutable query to get_stage...')
	response = network_provider.query_contract(query).to_dictionary()
	print(response)
	return_code = response['returnCode']
	if return_code != 'ok':
		print('Error in the response')
		return None
	return_data = response['returnData']
	output_type = 'Stage'
	return_data = return_data[0]
	decode_method = base64_string_to_numeric
	decoded_response = decode_method(return_data)
	print(decoded_response)

def mutate_setup_network(city_id, vertices_count, edges_count, storage_addr, hash, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		city_id - u64
		vertices_count - u64
		edges_count - u64
		storage_addr - array46<u8>
		hash - array32<u8>
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="setup_network",
		gas_limit=60000000,
		arguments=[city_id, vertices_count, edges_count, storage_addr, hash]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to setup_network...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_clear_network(city_id, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		city_id - u64
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="clear_network",
		gas_limit=60000000,
		arguments=[city_id]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to clear_network...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_upload_file(file_location, file_type, round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		file_location - array46<u8>
		file_type - FileType
		round - u32
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="upload_file",
		gas_limit=60000000,
		arguments=[file_location, file_type, round]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to upload_file...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_clear_file(file_location, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		file_location - array46<u8>
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="clear_file",
		gas_limit=60000000,
		arguments=[file_location]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to clear_file...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_evaluate_file(file_location, status, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		file_location - array46<u8>
		status - EvaluationStatus
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="evaluate_file",
		gas_limit=60000000,
		arguments=[file_location, status]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to evaluate_file...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_signup_user(native_amount = 1, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="signup_user",
		gas_limit=60000000,
		native_transfer_amount=native_amount,
		arguments=[]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to signup_user...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_clear_user(wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="clear_user",
		gas_limit=60000000,
		arguments=[]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to clear_user...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_update_reputation(user_addr, reputation, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		user_addr - Address
		reputation - u32
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="update_reputation",
		gas_limit=60000000,
		arguments=[user_addr, reputation]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to update_reputation...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_next_round(wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="next_round",
		gas_limit=60000000,
		arguments=[]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to next_round...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_set_round(round, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		round - u32
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="set_round",
		gas_limit=60000000,
		arguments=[round]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to set_round...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

def mutate_set_stage(stage, wallet_path = WALLET_PATH, caller_user_addr = CALLER_USER_ADDR):
	"""Parameters description
		stage - Stage
	"""
	signer = UserSigner.from_pem_file(Path(wallet_path))
	user_addr = Address.from_bech32(caller_user_addr)
	nonce_holder = AccountNonceHolder(network_provider.get_account(user_addr).nonce)
	call_transaction = sc_factory.create_transaction_for_execute(
		sender=user_addr,
		contract=contract_address,
		function="set_stage",
		gas_limit=60000000,
		arguments=[stage]
	)
	local_nonce = nonce_cache.get(caller_user_addr, -1)
	gateway_nonce = nonce_holder.get_nonce_then_increment()
	curr_nonce = max(local_nonce, gateway_nonce) # the higher value is the right one
	nonce_cache[caller_user_addr] = curr_nonce + 1 # setting the next nonce value
	call_transaction.nonce = curr_nonce
	call_transaction.signature = signer.sign(transaction_computer.compute_bytes_for_signing(call_transaction))
	print(f'>>>Performing mutable call to set_stage...')
	response = network_provider.send_transaction(call_transaction)
	print(f'>>>Transaction hash: {response}')

